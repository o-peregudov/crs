//////////////////////////////////////////////////////////////////////
//
// i41serial.cpp
// (c) 2010 Oleg N. Peregudov
//
//////////////////////////////////////////////////////////////////////

#include <crs/sc/i41serial.h>
#include <sstream>
#include <iomanip>

namespace sc {

std::string i41serial::comPacket::byteString () const
{
	std::basic_ostringstream<char> stream;
	stream.setf( std::ios_base::uppercase );
	stream.fill( '0' );
	for( size_t i = 0; i < sizeof( eightBytePacket ); ++i )
	{
		if( i )
			stream << ' ';
		stream << std::setw( 2 ) << std::hex << static_cast<int>( byteArray[ i++ ] );
		stream << ' ' << std::setw( 2 ) << std::hex << static_cast<int>( byteArray[ i ] );
	}
      return stream.str();
}

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

i41serial::i41serial( const size_t inBufSize )
	: rs232port( inBufSize )
	, evntSyncWaitState( false, true )
	, evntSyncPacket()
	, evntIncomingPacket()
	, _incomingPacket( )
	, _outgoingPacket( )
      , _inbox( )
	, _inboxLock( )
	, _comSectionLock( )
{
}

i41serial::~i41serial()
{
	kill();
	close();
}

void i41serial::pop ()
{
	CrossClass::_LockIt exclusive_access ( _inboxLock, true );
      if( !_inbox.empty() )
            _inbox.pop_front();
}

bool i41serial::peekPacket ( comPacket & packet )
{
	CrossClass::_LockIt exclusive_access ( _inboxLock, true );
      if( _inbox.empty() )
            return false;
      memcpy( packet.byteArray, _inbox.front().byteArray, sizeof( eightBytePacket ) );
      return true;
}

bool i41serial::tracePacket ( const comPacket & inPacket )
{
	// меняем местами старшие и младшие 4 бита в байте _outgoingPacket[0]
	// и сравниваем результат с inPacket[0]
	unsigned char TmpByte ( (inPacket.byteArray[ 0 ] << 4)|(inPacket.byteArray[ 0 ] >> 4) );
	if( _outgoingPacket.byteArray[ 0 ] != TmpByte )
		return false;						// асинхронный пакет
	else if( inPacket.byteArray[ 1 ] != _outgoingPacket.byteArray[ 1 ] )
		return ( inPacket.byteArray[ 1 ] > 0xEF );	// ошибка контроллера?
	else
		return true;						// синхронный пакет!
}

void	i41serial::checkPacket ( const comPacket & inPacket )
{
	if( inPacket.checkIdentity() )
	{
		if( inPacket.byteArray[ 1 ] != _outgoingPacket.byteArray[ 1 ] )
		{
			std::string msgText = "Request: ";
			msgText += _outgoingPacket.byteString();
			switch( inPacket.byteArray[ 1 ] )
			{
			case  0xF0:
	                  throw crcError( ( msgText += "; controller code 0xF0." ) );
			
			case  0xF1:
	                  throw badAddress( ( msgText += "; controller code 0xF1." ) );
	            
			case  0xF2:
				throw badCommand( ( msgText += "; controller code 0xF2." ) );
			
			case  0xF3:
				throw controllerOverflow( ( msgText += "; controller code 0xF3." ) );
			}
		}
      }
	else
		throw crcError( "Контрольная сумма входящего пакета не совпадает!" );
}

bool i41serial::synchronize ( const unsigned long dwTimeOut )
{
	bool wasActive = active ();	// save current activation state
	if( wasActive )
		Stop();			// suspend the thread
	try
	{
		for( int i = 0; i < 15; ++i )
		{
			write( "U", 1 );
			for( int j = 0; j < 50; ++j )
			{
				CrossClass::sleep( 1 );
				receive();
				if( evntSyncPacket.WaitEvent( 50 ) )
				{
					evntSyncPacket.ResetEvent();
					throw int( 0 );
				}
			}
		}
	}
	catch( int )
	{
		if( wasActive )
			Resume();
		return true;
	}
	catch( ... )
	{
		throw;
	}
	if( wasActive )
		Resume();
	return false;
}

size_t i41serial::compileResponse ( const char * lpBuf, const size_t dwAvailable )
{
	try
	{
	
	comPacket packet;
	size_t nBytesProcessed = 0;
	while( ( dwAvailable - nBytesProcessed ) >= sizeof( eightBytePacket ) )
	{
            memcpy( packet.byteArray, lpBuf + nBytesProcessed, sizeof( eightBytePacket ) );
		nBytesProcessed += sizeof( eightBytePacket );
		if( evntSyncWaitState.WaitEvent( 0 ) )
		{
			std::cout << "sw-" << std::flush;
			if( tracePacket( packet ) )
			{
				_incomingPacket = packet;
				evntIncomingPacket.SetEvent();
				evntSyncWaitState.ResetEvent();
				continue;
			}
			else
				std::cout << "failed to trace packet!" << std::endl;
		}
		else if( packet.syncPacket() )
		{
			std::cout << "sync" << std::endl;
            	/* synchronization packet which consists of eight 'U' chars */
			evntSyncPacket.SetEvent();
			continue;
		}
		
		{
			CrossClass::_LockIt exclusive_access ( _inboxLock, true );
			_inbox.push_back( packet );
		}
		incomingData();
      }
      return nBytesProcessed;
	
	}
	catch( std::runtime_error & e )
	{
		std::cout << "exception in compileResponse: " << e.what() << std::endl;
	}
	catch( ... )
	{
		throw;
	}
}

void i41serial::comSection ( const comPacket & outPacket, comPacket & inPacket, const unsigned long msTimeOut )
{
	try
	{
		{
			CrossClass::_LockIt exclusive_access ( _comSectionLock, true );
			_outgoingPacket = outPacket;
			evntSyncWaitState.SetEvent();
			std::cout << "cs-" << std::flush;
			send( outPacket );
		}
		if( evntIncomingPacket.WaitEvent( msTimeOut ) )
		{
			std::cout << "sp" << std::endl;
			inPacket = _incomingPacket;
			checkPacket( inPacket );
		}
		else
			throw syncTimeOut( "i41serial::comSection()" );
	}
	catch( syncTimeOut & e )
	{
		std::cout << "timeout in comSection" << std::endl;
		throw;
	}
	catch( std::runtime_error & e )
	{
		std::cout << "exception in comSection: " << e.what() << std::endl;
	}
	catch( ... )
	{
		throw;
	}
}

} // namespace sc
